# 数组二叉树

二叉树也可以用数组来存储，给定一个数组，树的根节点的值存储在下标1，对于存储在下标N的节点，它的左子节点和右子节点分别存储在下标2*N和2*N+1，并且我们用值-1代表一个节点为空。

给定一个数组存储的二叉树，试求从根节点到最小的叶子节点的路径，路径由节点的值组成。

输入描述:
输入一行为数组的内容，数组的每个元素都是正整数，元素间用空格分隔。注意第一个元素即为根节点的值，即数组的第N个元素对应下标N，下标0在树的表示中没有使用，所以我们省略了。输入的树最多为7层。
输出描述:
输出从根节点到最小叶子节点的路径上，各个节点的值，由空格分隔，用例保证最小叶子节点只有一个。

示例1
输入
3 5 7 -1 -1 2 4
输出
3 7 2
说明
数组存储的二叉树如图，故到最小叶子节点的路径为3 7 2
示例2
输入
5 9 8 -1 -1 7 -1 -1 -1 -1 -1 6
输出
5 8 7 6
说明
数组存储的二叉树如图，故到最小叶子节点的路径为10 8 7 6，注意数组仅存储至最后一个非空节点，故不包含节点“7”右子节点的-1

```
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        ArrayList<Integer> array = new ArrayList<>();

        while (in.hasNextInt()) {
            array.add(in.nextInt());
        }
        fun(array);

    }

    private static int dfs(List<Integer> nums, int index) {
        if (isLeaf(nums, index)) {
            return index;
        } else {
            int i1 = dfs(nums, 2 * index + 1);
            int i2 = dfs(nums, 2 * index + 2);
            if (i1 >= nums.size() || nums.get(i1) == -1) {
                return i2;
            } else if (i2 >= nums.size() || nums.get(i2) == -1) {
                return i1;
            } else {
                return nums.get(i1) < nums.get(i2) ? i1 : i2;
            }
        }
    }

    private static boolean isLeaf(List<Integer> nums, int index) {
        return (2 * index + 1 >= nums.size() || nums.get(2 * index + 1) == -1)
                && (2 * index + 2 >= nums.size() || nums.get(2 * index + 2) == -1);
    }

    private static void fun(List<Integer> nums) {
        int index = dfs(nums, 0);
        ArrayList<Integer> arr = new ArrayList<>();
        while (index > 0) {
            arr.add(nums.get(index));
            index = (index - 1) / 2;
        }
        arr.add(nums.get(0));

        Collections.reverse(arr);
        for (Integer integer : arr) {
            System.out.print(integer + " ");
        }
    }
}
```

